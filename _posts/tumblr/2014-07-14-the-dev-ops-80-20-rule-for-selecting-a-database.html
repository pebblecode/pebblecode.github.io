---
layout: post
title: The dev-ops 80-20 rule for selecting a Database Technology
date: '2014-07-14T15:44:00+01:00'
tags:
- databases
- foundationdb
- devops
- persistence
tumblr_url: http://blog.pebblecode.com/post/91747509426/the-dev-ops-80-20-rule-for-selecting-a-database
---
<p>Everyone in software is familiar with the 80-20 rule, or perhaps outside software less catchily known as the <a href="http://en.wikipedia.org/wiki/Pareto_principle">pareto principle</a> - the idea that you spend about 20% of the time it takes to complete a project building out the first 80% of the features, with the remaining 80% of the duration to complete the elusive final 20%.  There are countless applications of this idea - kind of like when you&rsquo;ve just learnt a new word, examples start to crop up everywhere.  The most recent example I&rsquo;ve come across describes the amount of time spent working with persistence technologies from the point of view of developers and operations.  But first some background.<br/><br/> In the days of working on back office software, if there wasn&rsquo;t a strong opinion already about how to solve a problem, developers were free to pick tools that met their basic checklist - will it work in production? Will the project cover the costs if they exist? And most importantly, HOW SHINY IS IT?<br/><br/> I&rsquo;m as guilty as the next developer of having picked tools to work with based primarily on how much I wanted to play with them.  Being an easy tool to code with use generally made my life as a developer easier, but it was also an easy sell to management - if it takes me, the expensive developer, less time to build a solution with, it must be good for the project.  Of course, over time, lots of counter examples have cropped up: just throw &ldquo;rails performance bottleneck&rdquo; or &ldquo;entity framework SQL fail&rdquo; into google and read to learn what happens when developer magic sauce is spread liberally and allowed to determine the architecture.  <br/><br/> The product I&rsquo;m working on at the moment generates a reasonable amount of financial data - around 10Gb / day. It turns out that when you need to keep everything, and the product is growing daily, managing an additional 10Gb of data every day can be moderately painful.  Painful to the extent that we have an operations team, one of whose key roles is essentially to keep everything running.  Over the last year or so we&rsquo;ve scaled vertically, <a href="http://en.wikipedia.org/wiki/2147483647">run out of 32-bit integers</a>, added lots of database nodes, added data centres and strategised about archiving operational data.<br/><br/> Turns out I had fallen victim to the most common of easy vs simple fails.  In architecting the original product, I&rsquo;d focussed on tools that I knew - those that were close at hand, that I was familiar with; and therefore easy for me, the developer to use.  In this case MySql.  Now, MySql is extremely capable of scaling to massive data volumes, it&rsquo;s currently powering numerous huge databases like Google Adwords and Facebook <a href="http://thenextweb.com/dd/2014/03/27/facebook-google-linkedin-twitter-launch-webscalesql-custom-version-mysql-massive-databases/">albeit in a much customised form</a>.  But scaling traditional RDBMs does come with a significant ops overhead.  For this particular product, the data architecture at the code level is now pretty mature, we almost never add new data fields.  But as a business, we spend <em>a lot</em> of time working with the data at the persistence level - just to keep the lights on and the replicas fresh.<br/><br/> On reflection, it seems I chose a persistence technology ignorant of the devops 80-20 rule.  I&rsquo;d estimate that to date, of all the many, many man-months of time the business has spent building and maintaining this product on MySql, about 20% of that time (if not less) was spent by developers on building the original product against that persistence mechanism, during which we benefitted from the wealth of developer tools and documentation at our disposal - it was easy to do.  At least 80% of the time has been spent by the operations team, keeping things going. <br/><br/> With my <a href="http://www.infoq.com/presentations/Simple-Made-Easy-QCon-London-2012">Simple made Easy</a> hat on, and my 20/20 hindsight goggles engaged, I see now that it was short sighted to select the easy, comfortable technology, the one that I had experience with, without understanding how the total cost of ownership (TCO) for my decision would be met largely by maintenance down the line, rather than the minimal build effort.<br/><br/> So what else can we do? I think the main learning point has been to select technology with a stronger consideration for TCO.  A less smooth developer experience may well be preferable to more complex operational maintenance strategy. The persistence marketplace these days is awash with distributed database solutions with significantly improved cluster management and auto-healing capabilities, offering different types of storage and varying levels of consistency.  Some of them <a href="https://foundationdb.com/">even support ACID</a>.</p>
